# Commentator

Система управления иерархическими древовидными комментариями. 

Древовидная иерархия хранится в реляционной базе данных. Для получения элементов дерева не используются SQL-запросы с рекурсией.

Для организации структуры комментариев применяется метод «Closure Table» совмещённым с «Adjacency List».

### Установка

##### После установки пакета необходимо последовательно выполнить следующие действия:

Добавить в файл конфигурации приложения _**config/app.php**_ сервис-провайдер.

```php
 \Drandin\ClosureTableComments\ClosureTableServiceProvider::class,
``` 

Данную строку следует внести массив 'providers'

Выполнить в консоли команду, которая скопирует файл конфигурации _**closure-table-comments.php**_ в каталог _**config**_ вашего приложения:

```
 php artisan vendor:publish --tag=config
```

(!) В файле _**config/closure-table-comments.php**_ вы можете изменить базы данных и таблиц. Если это необходимо, то скорректируйте параметры конфигурации, прежде чем двигаться дальше.

Выполнить в консоли команду:

```
 php artisan config:cache
```

Выполнить в консоли команду, которая запустит выполнение миграций:

```
 php artisan migrate
```

В результате будут созданы **2** таблицы в базе данных.

### Использование

Каждый комментарий может относиться к определённому предмету и иметь ссылку на автора, который  его написал. 
Например, если требуется организовать обсуждение статьи на новостном сайте, то уникальный целочисленный идентификатор сущности «Статья» следует использовать в качестве указания на принадлежность комментариев к обсуждаемому предмету, а целочисленный идентификатор пользователя — будет указывать на автора комментария.

**subject_id** — целочисленный идентификатор сущности «Статья». Может иметь значение **NULL**. Если **subject_id** равняется **NULL**, то комментарий не будет относиться к какому-либо предмету.

**user_id** — целочисленный идентификатор сущности «Автор статьи». Может иметь значение **NULL**. Если **user_id** равняется **NULL**, то комментарий не будет принадлежать какому-либо автору. Такие комментарии можно считать анонимными. 

##### 1. Создание корневого нового комментария.

Предположим, у нас есть сущность «Статья» с уникальным номером **5636** и пользователь c уникальным идентификатором **7** решил оставить комментарий к статье.   

```php
  use Drandin\ClosureTableComments\ClosureTableService;
  use Drandin\ClosureTableComments\Commentator;

  $commentator = new Commentator(new ClosureTableService());

  $comment = "Отличная статья. Спасибо за полезный материал.";
    
  $id = $commentator
            ->setSubjectId(5636)
            ->getTreeBranch();
```

В базе данных будет создан комментарий с уникальным идентификатором **$id**, он будет принадлежать статье с кодом **5636**. Автором комментария будет пользователь с идентификатором **7**.

##### 2. Ответ на комментарий, который был написан ранее.

Предположим, у нас есть сущность «Статья» с уникальным номером **5636** и пользователь с уникальным идентификатором **43** решил ответить на ранее написанный другим пользователем комментарий к статье.

Для этого нам нужно знать идентификатор комментария (или уникальный номер узла в древовидной иерархии комментариев **Node**), на который пользователь хочет написать ответ. Предположим, что уникальный идентификатор комментария равен **1**.
   
 ```php
   use Drandin\ClosureTableComments\ClosureTableService;
   use Drandin\ClosureTableComments\Commentator;
 
   $commentator = new Commentator(new ClosureTableService());
   
   $comment = "А вот и нет, в статье есть ошибки.";
   
   $id = $commentator
        ->setSubjectId(2332)
        ->replyToComment(1, $comment, 43);
 ```

В базе данных будет создан новый комментарий с уникальным идентификатором **$id**, он будет принадлежать статье с идентификатором **5636**. Автором комментария будет пользователь с идентификатором **43**.

Здесь важно то, что новый добавленный комментарий будет связан с родительским комментарием (с идентификатором равным **1**). Кроме связи, уровень (**level**) нового комментария будет на единицу больше, чем уровень родительского комментария. 


##### 3. Редактирование текста комментария.

Для внесения изменения в текст комментарий нужно знать его уникальный идентификатор.  

 ```php
   use Drandin\ClosureTableComments\ClosureTableService;
   use Drandin\ClosureTableComments\Commentator;
 
   $commentator = new Commentator(new ClosureTableService());
   
   $comment = "Отличная статья. Благодарю автора.";
   
   $commentator->editComment(1, $comment);
 ```

##### 4. Проверка существования комментария

Вы можете узнать существует ли комментарий (узел в иерархии) по его уникальному идентификатору.

 ```php
   use Drandin\ClosureTableComments\ClosureTableService;
   use Drandin\ClosureTableComments\Commentator;
 
   $commentator = new Commentator(new ClosureTableService());
   
   $res = $commentator->has(2);
 ```
Если комментарий с уникальным идентификатором в древовидной структуре есть, то переменная **$res** будет равняться **true**.

##### 5. Получение комментария (узла в иерархии) по уникальному идентификатору

Предположим, что мы хотим получить объект **Node** по уникальному идентификатору, который равен **2**.

 ```php
   use Drandin\ClosureTableComments\ClosureTableService;
   use Drandin\ClosureTableComments\Commentator;
 
   $commentator = new Commentator(new ClosureTableService());
   
   $node = $commentator->getNode(2);
 ```

В случае, если комментарий с уникальным идентификатором **2** существует, метод **getNode** вернёт объект **Node**. Объект **Node** будет содержать информацию об узле иерархии комментариев. 

##### 6. Получение отсортированной ветки комментариев

Предположим у нас есть статья с уникальным идентификатором **5636**, к этой статье разные пользователи написали комментарии. Некоторые комментаторы начали дискуссию между собой. То есть, у нас образовалась древовидная структура комментариев. 

Но дискуссия возможна только если мы сможем корректно визуализировать структуру комментариев. Иначе пользователи просто не смогут общаться между собой.
Для этого необходимо сформировать список отсортированных комментариев (узлов древовидной структуры). При этом в данном отсортированном списке узлов должен быть указан уровнь каждого узла, а так же идентификатор узла родителя.

Для решения этой задачи следует использовать метод **getTreeBranch**

 ```php
   use Drandin\ClosureTableComments\ClosureTableService;
   use Drandin\ClosureTableComments\Commentator;
 
   $commentator = new Commentator(new ClosureTableService());
   
   $nodes = $commentator
                ->setSubjectId(5636)
                ->getTreeBranch();
```

В результате мы получим коллекцию объектов **Node**.

Если нужно получить узлы иерархии комментариев, начиная с узла с определённым идентификатором, то в метод **getTreeBranch** следует передать значение этого идентификатора.

 ```php
   use Drandin\ClosureTableComments\ClosureTableService;
   use Drandin\ClosureTableComments\Commentator;
 
   $commentator = new Commentator(new ClosureTableService());
   
   $nodes = $commentator
                ->setSubjectId(5636)
                ->getTreeBranch(2);
```
Мы получим коллекцию объектов всех узлов иерархии начиная с узла **2**.

##### 7. Получение массива древовидной иерархии

Получить массив дерева комментариев можно при помощи метода **getTreeBranchArray**. 

 ```php
   use Drandin\ClosureTableComments\ClosureTableService;
   use Drandin\ClosureTableComments\Commentator;
 
   $commentator = new Commentator(new ClosureTableService());
   
   $tree = $commentator
                ->setSubjectId(5636)
                ->getTreeBranchArray();
```

Если необходимо получить ветку комментариев, которая должна начинаться с определённого узла, то в метод **getTreeBranchArray** следует передать идентификатор этого узла иерархии.
